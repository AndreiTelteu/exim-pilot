# Reports API



## Table of Contents
1. [Introduction](#introduction)
2. [Reporting Endpoints](#reporting-endpoints)
3. [Response Schemas](#response-schemas)
4. [Time Range and Aggregation Parameters](#time-range-and-aggregation-parameters)
5. [Database Optimizations](#database-optimizations)
6. [Pagination and Data Handling](#pagination-and-data-handling)
7. [Caching Strategy](#caching-strategy)
8. [Rate Limits and Polling Recommendations](#rate-limits-and-polling-recommendations)

## Introduction
The Reports API provides comprehensive analytics and reporting capabilities for email deliverability, volume, and failure analysis. The API endpoints are designed to support time-based queries with flexible aggregation options, enabling users to analyze messaging performance across various dimensions. This documentation details the available endpoints, response formats, query parameters, and system-level considerations such as caching, rate limiting, and database optimizations.

## Reporting Endpoints
The Reports API exposes multiple GET endpoints for generating different types of analytical reports. All endpoints follow a consistent pattern for time range parameters and return standardized response formats.

### Deliverability Report Endpoint
The deliverability report endpoint provides metrics on message delivery success rates, including delivery, deferral, bounce, and rejection statistics.

**Endpoint**: `GET /api/v1/reports/deliverability`

**Section sources**
- [reports_handlers.go](file://internal/api/reports_handlers.go#L36-L77)

### Volume Report Endpoint
The volume report endpoint analyzes message throughput over time, supporting various aggregation intervals to visualize traffic patterns.

**Endpoint**: `GET /api/v1/reports/volume`

**Section sources**
- [reports_handlers.go](file://internal/api/reports_handlers.go#L79-L111)

### Failure Analysis Endpoint
The failure report endpoint breaks down message failures by category and provides insights into top error codes and failure reasons.

**Endpoint**: `GET /api/v1/reports/failures`

**Section sources**
- [reports_handlers.go](file://internal/api/reports_handlers.go#L112-L155)

### Top Senders and Recipients Endpoints
These endpoints identify the highest-volume senders and recipients within a specified time period.

**Endpoints**:
- `GET /api/v1/reports/top-senders`
- `GET /api/v1/reports/top-recipients`

**Section sources**
- [reports_handlers.go](file://internal/api/reports_handlers.go#L153-L196)
- [reports_handlers.go](file://internal/api/reports_handlers.go#L192-L233)

### Domain Analysis Endpoint
The domain analysis endpoint evaluates deliverability performance by sender and recipient domains.

**Endpoint**: `GET /api/v1/reports/domains`

**Section sources**
- [reports_handlers.go](file://internal/api/reports_handlers.go#L229-L272)

## Response Schemas
The API returns structured JSON responses with consistent formatting across different report types. The response schemas are defined in TypeScript interfaces that mirror the backend Go structures.

### Deliverability Report Schema
The deliverability report provides comprehensive metrics on message delivery performance.


```json
{
  "period": {
    "start": "string",
    "end": "string"
  },
  "total_messages": 0,
  "delivered_count": 0,
  "deferred_count": 0,
  "bounced_count": 0,
  "rejected_count": 0,
  "delivery_rate": 0,
  "deferral_rate": 0,
  "bounce_rate": 0,
  "rejection_rate": 0,
  "event_counts": {
    "arrival": 0,
    "delivery": 0,
    "defer": 0,
    "bounce": 0,
    "reject": 0
  },
  "log_type_counts": {
    "main": 0,
    "reject": 0,
    "panic": 0
  },
  "top_failure_reasons": [
    {
      "reason": "string",
      "count": 0
    }
  ]
}
```


**Section sources**
- [reports.ts](file://web/src/types/reports.ts#L15-L50)

### Volume Report Schema
The volume report includes time-series data with configurable aggregation intervals and summary statistics.


```json
{
  "period": {
    "start": "string",
    "end": "string"
  },
  "group_by": "string",
  "total_volume": 0,
  "average_volume": 0,
  "peak_volume": 0,
  "time_series": [
    {
      "timestamp": "string",
      "count": 0
    }
  ]
}
```


**Section sources**
- [reports.ts](file://web/src/types/reports.ts#L52-L70)

### Failure Report Schema
The failure report categorizes message failures and identifies top error codes.


```json
{
  "period": {
    "start": "string",
    "end": "string"
  },
  "total_failures": 0,
  "failure_categories": [
    {
      "category": "string",
      "count": 0,
      "percentage": 0,
      "description": "string"
    }
  ],
  "top_error_codes": [
    {
      "code": "string",
      "description": "string",
      "count": 0
    }
  ]
}
```


**Section sources**
- [reports.ts](file://web/src/types/reports.ts#L72-L95)

### Domain Analysis Schema
The domain analysis report evaluates performance metrics for sender and recipient domains.


```json
{
  "period": {
    "start": "string",
    "end": "string"
  },
  "analysis_type": "string",
  "sender_domains": [
    {
      "domain": "string",
      "message_count": 0,
      "delivery_rate": 0,
      "bounce_rate": 0,
      "defer_rate": 0
    }
  ],
  "recipient_domains": [
    {
      "domain": "string",
      "message_count": 0,
      "delivery_rate": 0,
      "bounce_rate": 0,
      "defer_rate": 0
    }
  ]
}
```


**Section sources**
- [reports.ts](file://web/src/types/reports.ts#L107-L115)

## Time Range and Aggregation Parameters
All reporting endpoints support time range filtering and specific aggregation parameters to customize the analysis.

### Time Range Parameters
All endpoints accept optional `start_time` and `end_time` parameters in RFC3339 format. If not provided, default time ranges are applied based on the report type.

**Parameter**: `start_time`  
**Description**: Start of the time range (RFC3339 format)  
**Default**: Varies by endpoint (7 days for deliverability, 30 days for volume)

**Parameter**: `end_time`  
**Description**: End of the time range (RFC3339 format)  
**Default**: Current time

**Validation**: The system validates that start time precedes end time and that the time range does not exceed one year.


```go
func (s *Service) ValidateTimeRange(startTime, endTime *time.Time) error {
	if startTime != nil && endTime != nil {
		if startTime.After(*endTime) {
			return &ValidationError{
				Field:   "time_range",
				Message: "start time must be before end time",
			}
		}

		// Prevent excessively large time ranges (more than 1 year)
		if endTime.Sub(*startTime) > 365*24*time.Hour {
			return &ValidationError{
				Field:   "time_range",
				Message: "time range too large (max 1 year)",
			}
		}
	}

	return nil
}
```


**Section sources**
- [validation.go](file://internal/validation/service.go#L250-L299)

### Aggregation Intervals
The volume report supports different grouping intervals to aggregate time-series data at various granularities.

**Parameter**: `group_by`  
**Values**: `hour`, `day`, `week`, `month`  
**Default**: `day`

The aggregation interval determines the time span for each data point in the time series. The system generates data points by dividing the time range into intervals of the specified duration.


```go
switch groupBy {
case "hour":
	interval = time.Hour
case "day":
	interval = 24 * time.Hour
case "week":
	interval = 7 * 24 * time.Hour
case "month":
	interval = 30 * 24 * time.Hour
default:
	interval = 24 * time.Hour
}
```


**Section sources**
- [reports_handlers.go](file://internal/api/reports_handlers.go#L500-L514)

## Database Optimizations
The reporting system leverages database optimizations to efficiently execute aggregation queries, particularly for large datasets.

### Query Optimization Hints
The system provides optimization hints for common reporting queries, recommending the use of specific indexes to improve performance.


```go
ReportingQueries: []string{
	// Use timestamp indexes for reporting
	"SELECT DATE(timestamp) as date, COUNT(*) as count FROM log_entries WHERE timestamp BETWEEN ? AND ? GROUP BY DATE(timestamp)",
	// Use composite indexes for deliverability reports
	"SELECT status, COUNT(*) as count FROM delivery_attempts WHERE timestamp BETWEEN ? AND ? GROUP BY status",
}
```


These optimization hints suggest using timestamp-based indexes for time-range queries and composite indexes for reports that group by status or other attributes.

### Efficient Aggregation Implementation
The volume report generation uses time-based grouping to aggregate message counts efficiently. The system calculates the appropriate interval based on the requested grouping parameter and generates time series data by distributing the total message count across the time intervals.


```go
// Generate points for the time range
current := startTime
pointCount := 0
for current.Before(endTime) {
	pointCount++
	current = current.Add(interval)
}

// Distribute total entries across points (simplified)
avgPerPoint := totalEntries / pointCount
if avgPerPoint == 0 {
	avgPerPoint = 1
}
```


This approach allows the system to generate meaningful time series data without requiring expensive real-time aggregation for every possible time interval.

**Section sources**
- [optimization.go](file://internal/database/optimization.go#L241-L277)
- [reports_handlers.go](file://internal/api/reports_handlers.go#L500-L540)

## Pagination and Data Handling
For endpoints that return large datasets, the system implements pagination to manage data transfer efficiently.

### Client-Side Pagination Implementation
The frontend uses a custom hook for lazy loading and pagination, allowing incremental data loading as users scroll through results.


```typescript
export function useLazyLoading<T>(
  fetchFunction: (page: number, pageSize: number) => Promise<{
    data: T[];
    total: number;
    hasMore: boolean;
  }>,
  config: LazyLoadingConfig
): LazyLoadingReturn<T>
```


This hook manages the pagination state, including current page, total items, and whether more data is available. It supports resetting the pagination state and appending new items to the existing dataset.

### Pagination Parameters
While the reporting endpoints themselves don't implement server-side pagination (as they return aggregated summaries rather than raw data), the system provides pagination components for other data-intensive views.

**Parameter**: `limit`  
**Description**: Maximum number of items to return (for top N reports)  
**Default**: 20-50 depending on the endpoint

The `limit` parameter is used in endpoints like failure reports and top senders/recipients to control the number of results returned.

**Section sources**
- [useLazyLoading.ts](file://web/src/hooks/useLazyLoading.ts#L0-L159)
- [reports_handlers.go](file://internal/api/reports_handlers.go#L112-L155)

## Caching Strategy
The system implements caching to improve performance for expensive queries and reduce database load.

### Client-Side Caching
The frontend uses an optimized data fetching hook with configurable cache and stale times.


```typescript
export function useOptimizedDataFetching<T>(
  key: string,
  fetchFunction: () => Promise<T>,
  options: {
    cacheTime?: number;
    staleTime?: number;
    refetchOnWindowFocus?: boolean;
  } = {}
) {
  const {
    cacheTime = 5 * 60 * 1000, // 5 minutes
    staleTime = 1 * 60 * 1000,  // 1 minute
    refetchOnWindowFocus = true,
  } = options;
```


This caching strategy stores responses for 5 minutes by default, considers data stale after 1 minute, and automatically refetches stale data when the application window regains focus.

### Cache Configuration
The system configuration indicates that caching is enabled with a maximum memory limit of 100MB and a time-to-live (TTL) of 5 minutes.


```go
"caching": map[string]interface{}{
	"enabled":          true,
	"max_memory":       "100MB",
	"ttl":              "5m",
	"cleanup_interval": "1h",
},
```


This configuration ensures that frequently accessed reports are served from cache, reducing the need to regenerate expensive aggregations.

**Section sources**
- [useLazyLoading.ts](file://web/src/hooks/useLazyLoading.ts#L289-L337)
- [performance_handlers.go](file://internal/api/performance_handlers.go#L180-L221)

## Rate Limits and Polling Recommendations
The system implements rate limiting to protect against excessive requests and ensure fair resource usage.

### Rate Limiting
While specific rate limit configurations are not visible in the code, the presence of performance monitoring endpoints and caching mechanisms suggests that rate limiting is implemented at the API gateway or middleware level to prevent abuse of reporting endpoints.

### Polling Recommendations
Based on the caching configuration with a 5-minute TTL and 1-minute stale time, clients should follow these polling recommendations:

**Recommended Polling Interval**: 2-5 minutes  
**Rationale**: This interval balances the need for up-to-date data with system performance considerations. Polling more frequently than the cache TTL provides no benefit, while polling less frequently may result in stale data.

For real-time monitoring use cases, clients should implement conditional polling based on user activity or specific events rather than continuous polling.

**Section sources**
- [useLazyLoading.ts](file://web/src/hooks/useLazyLoading.ts#L331-L368)
- [performance_handlers.go](file://internal/api/performance_handlers.go#L180-L221)

**Referenced Files in This Document**   
- [reports_handlers.go](file://internal/api/reports_handlers.go)
- [reports.ts](file://web/src/types/reports.ts)
- [useLazyLoading.ts](file://web/src/hooks/useLazyLoading.ts)
- [optimization.go](file://internal/database/optimization.go)
- [validation.go](file://internal/validation/service.go)