# Queue Management



## Table of Contents
1. [Introduction](#introduction)
2. [Core Components](#core-components)
3. [Architecture Overview](#architecture-overview)
4. [Frontend Implementation](#frontend-implementation)
5. [Backend Implementation](#backend-implementation)
6. [Queue Operations Workflow](#queue-operations-workflow)
7. [Bulk Operations](#bulk-operations)
8. [Search and Filtering](#search-and-filtering)
9. [Queue Health Monitoring](#queue-health-monitoring)
10. [Audit Logging and Security](#audit-logging-and-security)
11. [Performance Considerations](#performance-considerations)
12. [Common Issues and Best Practices](#common-issues-and-best-practices)

## Introduction
The Queue Management feature provides a comprehensive interface for monitoring and controlling the Exim mail queue. It enables administrators to view messages in the queue, perform individual and bulk operations (deliver, freeze, thaw, delete), and assess overall queue health. The system integrates a React-based frontend with a Go backend service that interfaces directly with the Exim spool and a database for persistent storage and historical tracking. This document details the implementation, functionality, and best practices for safe queue manipulation.

## Core Components
The Queue Management system consists of several key components that work together to provide a complete solution for mail queue administration. The frontend components include QueueList for displaying messages and BulkActions for performing operations on multiple messages. The backend includes the QueueHandlers for API endpoints, the QueueService for business logic, and the Manager for direct interaction with the Exim spool. The system also integrates with audit logging and permission checks to ensure secure operations.

**Section sources**
- [queue_handlers.go](file://internal/api/queue_handlers.go#L1-L395)
- [service.go](file://internal/queue/service.go#L1-L311)
- [queue.go](file://internal/queue/queue.go#L1-L397)
- [QueueList.tsx](file://web/src/components/Queue/QueueList.tsx#L1-L500)
- [BulkActions.tsx](file://web/src/components/Queue/BulkActions.tsx#L1-L442)

## Architecture Overview
The Queue Management system follows a layered architecture with a React frontend communicating with a Go backend via REST API endpoints. The backend service interfaces with the Exim mail server through command-line operations and maintains historical data in a database. WebSocket connections provide real-time updates to the frontend when queue changes occur.


```mermaid
graph TB
subgraph "Frontend"
QueueList[QueueList Component]
BulkActions[BulkActions Component]
useQueue[useQueue Hook]
end
subgraph "Backend"
QueueHandlers[QueueHandlers]
QueueService[QueueService]
Manager[Manager]
Database[(Database)]
end
QueueList --> useQueue
BulkActions --> useQueue
useQueue --> API[API Service]
API --> QueueHandlers
QueueHandlers --> QueueService
QueueService --> Manager
QueueService --> Database
Manager --> Exim[(Exim Spool)]
```


**Diagram sources**
- [queue_handlers.go](file://internal/api/queue_handlers.go#L1-L395)
- [service.go](file://internal/queue/service.go#L1-L311)
- [queue.go](file://internal/queue/queue.go#L1-L397)
- [QueueList.tsx](file://web/src/components/Queue/QueueList.tsx#L1-L500)
- [BulkActions.tsx](file://web/src/components/Queue/BulkActions.tsx#L1-L442)

## Frontend Implementation

### QueueList Component
The QueueList component displays messages from the Exim queue with support for pagination, sorting, and virtual scrolling for large datasets. It allows users to select individual messages or all messages at once, which enables bulk operations through the BulkActions component.


```mermaid
flowchart TD
Start([Component Mount]) --> FetchMessages["Fetch Messages via API"]
FetchMessages --> DisplayMessages["Display Messages in Table"]
DisplayMessages --> HandleUserInteraction["Handle User Interactions"]
HandleUserInteraction --> Sort{"Sort Requested?"}
Sort --> |Yes| FetchSorted["Fetch Sorted Data"]
Sort --> |No| Select{"Selection Changed?"}
Select --> |Yes| UpdateSelection["Update Selected Messages"]
Select --> |No| Page{"Page Changed?"}
Page --> |Yes| FetchPage["Fetch New Page"]
Page --> |No| RealTime{"Real-time Update?"}
RealTime --> |Yes| Refresh["Refresh Current View"]
RealTime --> |No| End([Component Active])
FetchSorted --> DisplayMessages
FetchPage --> DisplayMessages
Refresh --> DisplayMessages
UpdateSelection --> DisplayMessages
```


**Diagram sources**
- [QueueList.tsx](file://web/src/components/Queue/QueueList.tsx#L1-L500)

**Section sources**
- [QueueList.tsx](file://web/src/components/Queue/QueueList.tsx#L1-L500)

### BulkActions Component
The BulkActions component provides a user interface for performing operations on multiple selected messages. It includes confirmation dialogs for destructive operations like deletion, progress indicators during operation execution, and result feedback showing success and failure counts.


```mermaid
flowchart TD
Start([Operation Button Click]) --> ShowConfirmation["Show Confirmation Dialog"]
ShowConfirmation --> UserDecision{"User Confirmed?"}
UserDecision --> |No| Cancel["Cancel Operation"]
UserDecision --> |Yes| InitializeProgress["Initialize Progress Tracking"]
InitializeProgress --> ExecuteOperation["Execute Bulk Operation"]
ExecuteOperation --> UpdateProgress["Update Progress Incrementally"]
UpdateProgress --> OperationComplete{"Operation Complete?"}
OperationComplete --> |Yes| ShowResult["Show Result Feedback"]
OperationComplete --> |No| Continue["Continue Progress Updates"]
ShowResult --> ClearSelection["Clear Message Selection"]
ClearSelection --> End([Operation Complete])
Cancel --> End
```


**Diagram sources**
- [BulkActions.tsx](file://web/src/components/Queue/BulkActions.tsx#L1-L442)

**Section sources**
- [BulkActions.tsx](file://web/src/components/Queue/BulkActions.tsx#L1-L442)

## Backend Implementation

### Queue Service Architecture
The backend QueueService acts as an intermediary between the API handlers and the low-level Manager that interacts with Exim. It provides a clean interface for queue operations while handling business logic, validation, and integration with the database for audit logging.


```mermaid
classDiagram
class QueueService {
+GetQueueStatus() *QueueStatus
+GetMessageDetails(messageID string) *MessageDetails
+CreateQueueSnapshot() *QueueSnapshot
+StartPeriodicSnapshots(ctx context.Context, interval time.Duration)
+GetQueueHealth() *QueueHealth
+SearchQueueMessages(criteria *SearchCriteria) []QueueMessage
+DeliverNow(messageID string, userID string, ipAddress string) *OperationResult
+FreezeMessage(messageID string, userID string, ipAddress string) *OperationResult
+ThawMessage(messageID string, userID string, ipAddress string) *OperationResult
+DeleteMessage(messageID string, userID string, ipAddress string) *OperationResult
+BulkDeliverNow(messageIDs []string, userID string, ipAddress string) *BulkOperationResult
+BulkFreeze(messageIDs []string, userID string, ipAddress string) *BulkOperationResult
+BulkThaw(messageIDs []string, userID string, ipAddress string) *BulkOperationResult
+BulkDelete(messageIDs []string, userID string, ipAddress string) *BulkOperationResult
+GetOperationHistory(messageID string) []AuditLog
+GetRecentOperations(limit int) []AuditLog
+ValidateMessageID(messageID string) error
+GetQueueStatistics() *QueueStatistics
}
class Manager {
+ListQueue() *QueueStatus
+InspectMessage(messageID string) *MessageDetails
+CreateSnapshot() *QueueSnapshot
+DeliverNow(messageID string, userID string, ipAddress string) *OperationResult
+FreezeMessage(messageID string, userID string, ipAddress string) *OperationResult
+ThawMessage(messageID string, userID string, ipAddress string) *OperationResult
+DeleteMessage(messageID string, userID string, ipAddress string) *OperationResult
+BulkDeliverNow(messageIDs []string, userID string, ipAddress string) *BulkOperationResult
+BulkFreeze(messageIDs []string, userID string, ipAddress string) *BulkOperationResult
+BulkThaw(messageIDs []string, userID string, ipAddress string) *BulkOperationResult
+BulkDelete(messageIDs []string, userID string, ipAddress string) *BulkOperationResult
+GetOperationHistory(messageID string) []AuditLog
+GetRecentOperations(limit int) []AuditLog
+ValidateMessageID(messageID string) error
+parseQueueOutput(output string) *QueueStatus
+parseSize(sizeStr string) (int64, error)
+parseAge(ageStr string) time.Duration
+extractMessageID(line string) string
+parseHeaders(headersOutput string) map[string]string
+parseMessageLog(logOutput string) ([]string, []string)
}
class QueueHandlers {
+handleQueueList(w http.ResponseWriter, r *http.Request)
+handleQueueSearch(w http.ResponseWriter, r *http.Request)
+handleQueueDetails(w http.ResponseWriter, r *http.Request)
+handleQueueDeliver(w http.ResponseWriter, r *http.Request)
+handleQueueFreeze(w http.ResponseWriter, r *http.Request)
+handleQueueThaw(w http.ResponseWriter, r *http.Request)
+handleQueueDelete(w http.ResponseWriter, r *http.Request)
+handleQueueBulk(w http.ResponseWriter, r *http.Request)
+handleQueueHealth(w http.ResponseWriter, r *http.Request)
+handleQueueStatistics(w http.ResponseWriter, r *http.Request)
+handleQueueHistory(w http.ResponseWriter, r *http.Request)
}
QueueService --> Manager : "delegates to"
QueueHandlers --> QueueService : "uses"
QueueService --> Database : "stores snapshots"
```


**Diagram sources**
- [service.go](file://internal/queue/service.go#L1-L311)
- [queue.go](file://internal/queue/queue.go#L1-L397)
- [queue_handlers.go](file://internal/api/queue_handlers.go#L1-L395)

**Section sources**
- [service.go](file://internal/queue/service.go#L1-L311)
- [queue.go](file://internal/queue/queue.go#L1-L397)
- [queue_handlers.go](file://internal/api/queue_handlers.go#L1-L395)

### Queue Operations Sequence
The sequence of operations when performing a queue action involves multiple layers from the frontend to the Exim spool. This diagram shows the flow for a bulk delete operation as an example.


```mermaid
sequenceDiagram
participant UI as "UI (BulkActions)"
participant Hook as "useQueue Hook"
participant API as "API Service"
participant Handlers as "QueueHandlers"
participant Service as "QueueService"
participant Manager as "Manager"
participant Exim as "Exim Spool"
participant DB as "Database"
UI->>Hook : bulkDelete(messageIds)
Hook->>API : post('/v1/queue/bulk', {operation : 'delete', message_ids})
API->>Handlers : HTTP Request
Handlers->>Handlers : Validate request
Handlers->>Service : BulkDelete(messageIDs, userID, ipAddress)
Service->>Manager : BulkDelete(messageIDs, userID, ipAddress)
loop For each message
Manager->>Exim : exim -Mrm <message_id>
Exim-->>Manager : Success/Failure
Manager->>DB : Log operation in audit log
end
Manager-->>Service : BulkOperationResult
Service-->>Handlers : BulkOperationResult
Handlers-->>API : HTTP Response
API-->>Hook : Promise resolution
Hook-->>UI : Update UI state
```


**Diagram sources**
- [queue_handlers.go](file://internal/api/queue_handlers.go#L1-L395)
- [service.go](file://internal/queue/service.go#L1-L311)
- [queue.go](file://internal/queue/queue.go#L1-L397)

**Section sources**
- [queue_handlers.go](file://internal/api/queue_handlers.go#L1-L395)
- [service.go](file://internal/queue/service.go#L1-L311)
- [queue.go](file://internal/queue/queue.go#L1-L397)

## Queue Operations Workflow
The system supports four primary operations on queue messages: deliver, freeze, thaw, and delete. Each operation follows a similar workflow but with different Exim commands and business logic.

### Individual Operations
Individual operations are performed on a single message and are typically initiated from the message details view or through direct API calls.


```mermaid
flowchart TD
Start([Operation Request]) --> Validate["Validate Message ID"]
Validate --> |Invalid| Error["Return Error Response"]
Validate --> |Valid| CheckPermissions["Check User Permissions"]
CheckPermissions --> |Denied| PermissionError["Return 403 Forbidden"]
CheckPermissions --> |Granted| Execute["Execute Operation"]
Execute --> |Deliver| EximDeliver["Run: exim -M <message_id>"]
Execute --> |Freeze| EximFreeze["Run: exim -Mf <message_id>"]
Execute --> |Thaw| EximThaw["Run: exim -Mt <message_id>"]
Execute --> |Delete| EximDelete["Run: exim -Mrm <message_id>"]
EximDeliver --> Log["Log Operation in Database"]
EximFreeze --> Log
EximThaw --> Log
EximDelete --> Log
Log --> Response["Return Operation Result"]
Response --> UpdateUI["Update UI State"]
UpdateUI --> End([Operation Complete])
Error --> End
PermissionError --> End
```


**Diagram sources**
- [queue_handlers.go](file://internal/api/queue_handlers.go#L1-L395)
- [service.go](file://internal/queue/service.go#L1-L311)
- [queue.go](file://internal/queue/queue.go#L1-L397)

**Section sources**
- [queue_handlers.go](file://internal/api/queue_handlers.go#L1-L395)
- [service.go](file://internal/queue/service.go#L1-L311)
- [queue.go](file://internal/queue/queue.go#L1-L397)

## Bulk Operations
Bulk operations allow administrators to perform actions on multiple messages simultaneously, improving efficiency when managing large queues.

### Bulk Operations Implementation
The bulk operations feature enables users to select multiple messages and apply operations like deliver, freeze, thaw, or delete to all selected messages at once.


```mermaid
classDiagram
class BulkOperationResult {
+operation QueueOperation
+total_requested int
+successful int
+failed int
+errors []ErrorDetail
}
class BulkOperationProgress {
+operation QueueOperation
+total int
+completed int
+failed int
+in_progress bool
}
class QueueOperation {
<<enumeration>>
deliver
freeze
thaw
delete
}
class ErrorDetail {
+message_id string
+error string
}
BulkOperationResult --> ErrorDetail : "has"
```


**Diagram sources**
- [queue.ts](file://web/src/types/queue.ts#L55-L96)

**Section sources**
- [queue.ts](file://web/src/types/queue.ts#L55-L96)
- [BulkActions.tsx](file://web/src/components/Queue/BulkActions.tsx#L1-L442)

### Bulk Operations Sequence
The sequence for bulk operations involves collecting selected message IDs, validating the request, and executing the operation on each message while tracking progress and results.


```mermaid
sequenceDiagram
participant UI as "UI"
participant Service as "QueueService"
participant Manager as "Manager"
participant Exim as "Exim Spool"
UI->>Service : BulkDelete([msg1, msg2, msg3])
Service->>Manager : BulkDelete([msg1, msg2, msg3], user, ip)
loop For each message ID
Manager->>Exim : exim -Mrm <message_id>
Exim-->>Manager : Exit code
Manager->>Manager : Record success/failure
end
Manager-->>Service : BulkOperationResult
Service-->>UI : Operation result
```


**Diagram sources**
- [service.go](file://internal/queue/service.go#L1-L311)
- [queue.go](file://internal/queue/queue.go#L1-L397)

**Section sources**
- [service.go](file://internal/queue/service.go#L1-L311)
- [queue.go](file://internal/queue/queue.go#L1-L397)

## Search and Filtering
The system provides robust search and filtering capabilities to help administrators locate specific messages in the queue based on various criteria.

### Search Criteria
Users can search for messages using multiple criteria including sender, recipient, message ID, status, size, age, and retry count.


```mermaid
classDiagram
class SearchCriteria {
+Sender string
+Recipient string
+MessageID string
+Status string
+MinAge string
+MaxAge string
+MinSize int64
+MaxSize int64
+MinRetries int
+MaxRetries int
}
class QueueMessage {
+ID string
+Size int64
+Age string
+Sender string
+Recipients []string
+Status string
+RetryCount int
+LastAttempt time.Time
+NextRetry time.Time
}
QueueService --> SearchCriteria : "accepts"
QueueService --> QueueMessage : "returns"
QueueService --> QueueMessage : "filters by"
```


**Diagram sources**
- [service.go](file://internal/queue/service.go#L1-L311)

**Section sources**
- [service.go](file://internal/queue/service.go#L1-L311)

### Search Workflow
The search functionality allows users to find messages matching specific criteria, which is particularly useful in large queues.


```mermaid
flowchart TD
Start([User Enters Search Criteria]) --> Validate["Validate Search Parameters"]
Validate --> |Invalid| Error["Show Validation Error"]
Validate --> |Valid| FetchQueue["Fetch Full Queue"]
FetchQueue --> |Error| QueueError["Show Queue Error"]
FetchQueue --> |Success| FilterMessages["Filter Messages by Criteria"]
FilterMessages --> ApplyPagination["Apply Pagination to Results"]
ApplyPagination --> ReturnResults["Return Filtered Results"]
ReturnResults --> Display["Display Results in UI"]
Display --> End([Search Complete])
Error --> End
QueueError --> End
```


**Diagram sources**
- [service.go](file://internal/queue/service.go#L1-L311)
- [queue_handlers.go](file://internal/api/queue_handlers.go#L1-L395)

**Section sources**
- [service.go](file://internal/queue/service.go#L1-L311)
- [queue_handlers.go](file://internal/api/queue_handlers.go#L1-L395)

## Queue Health Monitoring
The system provides comprehensive queue health monitoring to help administrators assess the overall state of the mail queue and identify potential issues.

### Queue Health Metrics
The QueueHealth struct contains key metrics for assessing the health of the mail queue, including total messages, deferred messages, frozen messages, oldest message age, and growth trend.


```mermaid
classDiagram
class QueueHealth {
+TotalMessages int
+DeferredMessages int
+FrozenMessages int
+OldestMessageAge time.Duration
+GrowthTrend int
+Timestamp time.Time
}
class QueueStatistics {
+TotalMessages int
+QueuedMessages int
+DeferredMessages int
+FrozenMessages int
+TotalSize int64
+AverageSize int64
+OldestMessageAge time.Duration
+StatusBreakdown map[string]int
+SizeDistribution map[string]int
}
QueueService --> QueueHealth : "provides"
QueueService --> QueueStatistics : "provides"
```


**Diagram sources**
- [service.go](file://internal/queue/service.go#L1-L311)

**Section sources**
- [service.go](file://internal/queue/service.go#L1-L311)

### Health Monitoring Workflow
The system periodically captures queue snapshots to track historical trends and calculate growth rates, providing insights into queue behavior over time.


```mermaid
flowchart TD
Start([Start Periodic Snapshots]) --> CreateInitial["Create Initial Snapshot"]
CreateInitial --> StartTimer["Start Timer for Interval"]
StartTimer --> TimerFired{"Timer Fired?"}
TimerFired --> |No| Wait["Wait for Next Interval"]
TimerFired --> |Yes| CreateSnapshot["Create Queue Snapshot"]
CreateSnapshot --> |Success| StoreSnapshot["Store Snapshot in Database"]
CreateSnapshot --> |Error| LogError["Log Error"]
StoreSnapshot --> CalculateTrend["Calculate Growth Trend"]
CalculateTrend --> UpdateHealth["Update Queue Health Metrics"]
UpdateHealth --> Wait
LogError --> Wait
```


**Diagram sources**
- [service.go](file://internal/queue/service.go#L1-L311)

**Section sources**
- [service.go](file://internal/queue/service.go#L1-L311)

## Audit Logging and Security
All queue operations are logged for security, compliance, and troubleshooting purposes. The system integrates with the audit service to record who performed what action on which message and when.

### Audit Logging Implementation
Every queue operation is recorded in the database with details including the user ID, IP address, operation type, message ID, and timestamp.


```mermaid
sequenceDiagram
participant Handler as "QueueHandlers"
participant Service as "QueueService"
participant Manager as "Manager"
participant DB as "Database"
Handler->>Service : Operation Request
Service->>Manager : Operation Request
Manager->>Exim : Execute Exim Command
Exim-->>Manager : Result
Manager->>DB : Insert Audit Log
DB-->>Manager : Confirmation
Manager-->>Service : Operation Result
Service-->>Handler : Operation Result
```


**Diagram sources**
- [queue_handlers.go](file://internal/api/queue_handlers.go#L1-L395)
- [service.go](file://internal/queue/service.go#L1-L311)
- [queue.go](file://internal/queue/queue.go#L1-L397)

**Section sources**
- [queue_handlers.go](file://internal/api/queue_handlers.go#L1-L395)
- [service.go](file://internal/queue/service.go#L1-L311)
- [queue.go](file://internal/queue/queue.go#L1-L397)

## Performance Considerations
The system is designed to handle large queues efficiently with features like virtual scrolling, pagination, and optimized data fetching.

### Virtual Scrolling
For large datasets, the system implements virtual scrolling to render only visible items, significantly improving performance and reducing memory usage.


```mermaid
flowchart TD
Start([User Scrolls Queue List]) --> IsVirtualizationEnabled{"Virtualization Enabled?"}
IsVirtualizationEnabled --> |No| RenderAll["Render All Items"]
IsVirtualizationEnabled --> |Yes| CalculateVisible["Calculate Visible Items"]
CalculateVisible --> FetchVisible["Fetch Visible Page"]
FetchVisible --> RenderVisible["Render Visible Items"]
RenderVisible --> HandleScroll{"Scroll Position Changed?"}
HandleScroll --> |Yes| Recalculate["Recalculate Visible Items"]
HandleScroll --> |No| Wait["Wait for Scroll"]
Recalculate --> FetchVisible
Wait --> HandleScroll
```


**Diagram sources**
- [QueueList.tsx](file://web/src/components/Queue/QueueList.tsx#L1-L500)

**Section sources**
- [QueueList.tsx](file://web/src/components/Queue/QueueList.tsx#L1-L500)

### Performance Testing
The system includes comprehensive performance tests to ensure responsiveness under various conditions, including large datasets and frequent updates.


```mermaid
flowchart TD
Test1([Test Virtual Scrolling with 1000+ Messages]) --> VerifyRender["Verify Only Visible Items Rendered"]
VerifyRender --> TestScroll["Test Scrolling Performance"]
Test2([Test Performance with Frequent Updates]) --> SimulateUpdates["Simulate Real-time Updates"]
SimulateUpdates --> VerifyThrottling["Verify API Requests Throttled"]
Test3([Test Rapid User Interactions]) --> SimulateRapidActions["Simulate Rapid Selection/Deselection"]
SimulateRapidActions --> VerifyResponsiveness["Verify UI Remains Responsive"]
VerifyRender --> Pass1["Pass if Rendered Count < Threshold"]
TestScroll --> Pass2["Pass if Scroll Smooth"]
VerifyThrottling --> Pass3["Pass if Requests < Threshold"]
VerifyResponsiveness --> Pass4["Pass if Interaction Time < Threshold"]
```


**Diagram sources**
- [queue.spec.ts](file://tests/frontend/queue.spec.ts#L1-L476)

**Section sources**
- [queue.spec.ts](file://tests/frontend/queue.spec.ts#L1-L476)

## Common Issues and Best Practices

### Common Issues
When managing the Exim queue, administrators may encounter several common issues that can affect system performance and reliability.

**Queue Lock Contention**: When multiple processes attempt to modify the queue simultaneously, Exim's queue locking mechanism can cause operations to block or fail. This is particularly common during bulk operations on large queues.

**Performance Under High Load**: Large queues with thousands of messages can impact the performance of queue listing operations, especially when using commands like `exim -bp` which must scan the entire queue directory.

**Partial Operation Failures**: During bulk operations, some messages may fail to process due to various reasons such as invalid message IDs or file system issues, requiring careful error handling and reporting.

### Best Practices for Safe Queue Manipulation
To ensure safe and effective queue management, follow these best practices:

1. **Always Verify Message IDs**: Before performing operations, validate that message IDs exist and are in the expected state to prevent errors.

2. **Use Bulk Operations Judiciously**: While bulk operations improve efficiency, they should be used carefully, especially for destructive operations like deletion. Always confirm with the user before proceeding.

3. **Monitor Queue Health Regularly**: Regularly check queue health metrics to identify growing backlogs or unusual patterns that may indicate underlying issues.

4. **Implement Proper Error Handling**: Ensure that operations include comprehensive error handling and provide clear feedback to users about success and failure rates.

5. **Leverage Search and Filtering**: Use search and filtering capabilities to target specific messages rather than operating on the entire queue unnecessarily.

6. **Review Audit Logs**: Regularly review audit logs to track changes and identify any unauthorized or problematic operations.

7. **Test Operations in Staging**: When possible, test queue operations in a staging environment before applying them to production systems.

8. **Schedule Maintenance During Off-Peak Hours**: Perform major queue cleanup operations during periods of low mail volume to minimize impact on legitimate email delivery.

**Section sources**
- [queue_handlers.go](file://internal/api/queue_handlers.go#L1-L395)
- [service.go](file://internal/queue/service.go#L1-L311)
- [queue.go](file://internal/queue/queue.go#L1-L397)
- [QueueList.tsx](file://web/src/components/Queue/QueueList.tsx#L1-L500)
- [BulkActions.tsx](file://web/src/components/Queue/BulkActions.tsx#L1-L442)
- [queue.spec.ts](file://tests/frontend/queue.spec.ts#L1-L476)

**Referenced Files in This Document**   
- [queue_handlers.go](file://internal/api/queue_handlers.go#L1-L395)
- [service.go](file://internal/queue/service.go#L1-L311)
- [queue.go](file://internal/queue/queue.go#L1-L397)
- [QueueList.tsx](file://web/src/components/Queue/QueueList.tsx#L1-L500)
- [BulkActions.tsx](file://web/src/components/Queue/BulkActions.tsx#L1-L442)
- [queue.ts](file://web/src/types/queue.ts#L55-L96)
- [useQueue.ts](file://web/src/hooks/useQueue.ts#L38-L83)
- [queue.spec.ts](file://tests/frontend/queue.spec.ts#L1-L476)